== Microservices Lab scenario

=== Installing Hal tool

Download and install the `hal` tool from the project `https://github.com/halkyonio/hal/releases/tag/v0.1.2`

===== Binary installation for Mac OS

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.3/hal_0.1.3_Darwin_x86_64.tar.gz | tar -xz -C /usr/local/bin/ && chmod +x /usr/local/bin/hal
----

===== Binary installation for Linux

----
# curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.3/hal_0.1.3_Linux_x86_64.tar.gz -o /usr/local/bin/ && chmod +x /usr/local/bin/hal
----

**Remark**:

If the `/usr/local/bin` folder is owned by `root` and that your user don't has the permissions, then prefix the command with `sudo`.
----
sudo curl -sL https://github.com/halkyonio/hal/releases/download/v0.1.1/hal_0.1.1_Linux_x86_64.tar.gz \
  -o /usr/local/bin/hal_0.1.1_Linux_x86_64.tar.gz && \
  sudo tar -xzf /usr/local/bin/hal_0.1.1_Linux_x86_64.tar.gz \
  -C /usr/local/bin && sudo chmod +x /usr/local/bin/hal
----

===== Windows

TODO

===== Docker

If Docker is installed on your laptop and that you can access it, then you can also use the following `Hal` container image to play with it

NOTE: The image already packages the `kubectl` client.

----
docker run --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.3 bash
hal version
----

**Remark**: Check with the instructor the latest image to be used for the hal tool !!

Using this docker container, you can also execute the `oc` commands as presented hereafter
----
docker run --name hal -v "/path/to/lab/dir:/home/lab" -it quay.io/halkyonio/hal:v0.1.3 bash
oc login api.cluster-416e.416e.sandbox352.opentlc.com:6443 -u user1 -p r3dh4t1!
The server uses a certificate signed by an unknown authority.
You can bypass the certificate check, but any data you send to the server could be intercepted by others.
Use insecure connections? (y/n): y

Login successful.

You have access to 56 projects, the list has been suppressed. You can list all projects with 'oc projects'
----

=== Create a Git project

Git clone a project within a terminal from the github org https://github.com/rhte-eu (for the EU Session Lab) or https://github.com/rhte-us (for the US Session Lab)
using as repo name `user**1**`, ....., `user**N**`

----
curl -L https://raw.githubusercontent.com/halkyonio/rhte_lab_2019/master/git-create.sh --output git-create.sh && chmod +x git-create.sh
./git-create.sh
Repo name (hit enter to use 'rhte_lab_2019')?
<YOUR_GIT_REPO>
Creating Github repository 'rhte_lab_2019' under 'rhte-eu' ...
curl -u xxxxx:yyyyy https://api.github.com/orgs/rhte-eu/repos -d '{name:$repo_name, description:My cool $repo_name, private: false, has_issues: false, has_projects: true, has_wiki:false }'
 done.
----

Rename the name of the cloned project to `rhtelab` and move under this folder
----
mv user1 rhtelab && cd rhtelab
----

=== Log on to the OpenShift cluster

Log on to the RHTE OCP4 cluster using the `oc` client
----
oc login <SERVER_ADDRESS> -u user1 -p r3d4t1!
----

**Remarks**:
- The `<SERVER_ADDRESS>` corresponds to the Openshift API Server address (e.g: `api.cluster-416e.416e.sandbox352.opentlc.com:6443`) as reported within the lab setup part.
- As every student has a dedicated OCP cluster, then always use the user --> `user1`

Grant the `admin` role to your user `user1`
----
oc adm policy add-cluster-role-to-user admin user1 --as=system:admin
----

=== Create a new namespace

Create a new namespace
----
oc new-project rhtelab
----

=== Scaffold the Spring Boot applications

Create a new client project using the REST HTTP `client` template proposed by the scaffolding tool:
----
hal component spring-boot \
   -i fruit-client-sb \
   -g me.fruitsand \
   -p me.fruitsand.demo \
   -s 2.1.6.RELEASE \
   -t client \
   -v 1.0.0-SNAPSHOT \
   --supported=false  \
  fruit-client-sb
----

Repeat the operation and use as template the `crud` type and `fruit-backend-sb` as maven project name:
----
hal component spring-boot \
   -i fruit-backend-sb \
   -g me.fruitsand \
   -p me.fruitsand.demo \
   -s 2.1.6.RELEASE \
   -t crud \
   -v 1.0.0-SNAPSHOT \
   --supported=false  \
  fruit-backend-sb
----

Create a `.gitignore` file ignore the files populated by your IDE or what maven will populate under `/target` directory
----
touch .gitignore
echo "*/target" >> .gitignore
echo ".idea/" >> .gitignore
----

Add the code scaffolded to your git project and push it to your git remote repository
----
git init
git add .gitignore fruit-backend-sb/ fruit-client-sb/
git commit -m "Initial project" -a
git remote add origin https://github.com/rhte-eu/rhte_lab_2019.git
git push -u origin master
----

=== Build the project

==== Client

Compile and generate the `uber jar` file of the Spring Boot application using the following command
----
mvn package -f fruit-client-sb
----

==== Backend

Repeat the command executed previously for the CRUD - backend microservice
----
mvn package -f fruit-backend-sb -Pkubernetes
----

**Remark**: We need to use the `kubernetes` profile because the project is set up to work both locally using H2 database for quick testing and "remotely" using a PostgreSQL database.

The  PostgreSQL connection information is provided in the `application-kubernetes.properties` file.

Note also that this file contains a Dekorate environment variable definition called `SPRING_PROFILES_ACTIVE` with a `kubernetes` value.
This is so that the supervisor knows to activate the Spring `kubernetes` profile, i.e. make Spring Boot uses `application-kubernetes.properties` when
booting instead of the default `application.properties`. `application-kubernetes.properties` relies on the existence of
environment variables for the different components of the database connection. These values will be provided by a database
capability to which our component will be linked: the capability will generate a secret containing these values and the link will
inject it our component. The secret will be named after your capability, adding the `-config` suffix to the name. So if your
capability is called `my-capability`, its associated secret will be named `my-capability-config`.

==== Push the Components

TODO: Explain a little what is a component and what will happen when we will do the push

----
hal component push -c fruit-client-sb,fruit-backend-sb
----

Check if the components have been correctly installed
----
kubectl get cp
or
oc get cp
----

NOTE:  though that if you access the associated services, they won't be working yet
because the components haven't been wired together yet. Hence why we need to following steps! :smile:

==== Create a PostgreSQL DB

Create a capability to create a PostgreSQL database:
    * `hal capability` in interactive mode: select version `10`, TODO: provide the detail of all the values to enter,
    name the capability: `postges-db`
    * TODO: add non-interactive command

Check the capability status: `kubectl get capabilities`/`oc get capabilities`

==== Link the microservices

NOTE: The project's `application.properties` relies on an environment variable called `${KUBERNETES_ENDPOINT_FRUIT}` as a value provider for the `endpoint.fruit` property.
This is the property the app relies on to connect to the backend endpoint.

We will therefore need to somehow provide a value for this environment variable. This will be accomplished by creating a link.

We now need to wire the `fruit-backend-sb` component with the `postgres-db` capability by creating a link between both:
    * `hal link`
    * select `component: fruit-backend-sb` as the target since we want to tell the `fruit-backend-sb` component about the DB
    * select secret as link type
    * select `<your capability name>-config` as secret (`postgres-db-config` if your capability is called `postgres-db`)
    * call the link whatever you want

Create a link targeting the `fruit-client-sb` component: `hal link` to let `fruit-client-sb` know about the backend:
    * `hal link`
    * select `component: fruit-client-sb` as the target
    * select no when asked whether to use a secret
    * enter `KUBERNETES_ENDPOINT_FRUIT=http://fruit-backend-sb:8080/api/fruits` as the env value
    * press enter to let `hal` know that you're done entering env variables

Check the link status: `kubectl get links`/`oc get links`

Wait for things to be settled

Push the components again (TODO: remove when https://github.com/halkyonio/operator/issues/141 is fixed)

==== Connect to the Endpoints/Routes

Try the backend service to see if it works
    - Get the routes `oc get routes`
    - Get the `HOST/PORT` of the `fruit-backend-sb` and paste it in a browser
    - Create some fruits

Try the client service to see if it works
    - Get the routes `oc get routes`
    - Get the `HOST/PORT` of the `fruit-client-sb`
    - `export FRONTEND_ROUTE_URL=<host-of-client-route>`
    - `curl http://${FRONTEND_ROUTE_URL}/api/client`